<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Jungwon Runner â€” Dino Clone</title>
<style>
  :root{
    --bg:#f7f7f7;
    --ground:#555;
    --runner:#222;
    --ob:#2a2a2a;
    --cloud:#dcdcdc;
    --text:#222;
  }
  html,body{
    height:100%;
    margin:0;
    background:var(--bg);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
    -webkit-tap-highlight-color: transparent;
  }
  .wrap{
    height:100%;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:20px;
    box-sizing:border-box;
  }
  canvas{
    background: linear-gradient(#f7f7f7,#f0f0f0);
    border:6px solid #2b2b2b;
    display:block;
    image-rendering: pixelated;
    touch-action: manipulation;
  }
  .hint{
    text-align:center;
    margin-top:8px;
    color:var(--text);
    font-size:13px;
  }
  @media (max-width:520px){
    canvas{ width: 360px; height:180px; }
  }
</style>
</head>
<body>
<div class="wrap">
  <div>
    <canvas id="c" width="900" height="200"></canvas>
    <div class="hint">Tap / Click or press <strong>Space</strong> to jump. Press <strong>R</strong> to restart when game over.</div>
  </div>
</div>

<script>
/* Dino-like runner (single-file)
   Controls:
     - Space / ArrowUp / Click / Touch -> jump (only when on ground)
     - R -> restart after game over
   Features:
     - speed increases over time
     - score and best score persisted with localStorage
     - random cactus obstacles
     - clouds and ground
*/

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

let W = canvas.width;
let H = canvas.height;

const GROUND_Y = H - 40;      // y coordinate of ground top
const GRAVITY = 0.7;
const JUMP_SPEED = -13;

let speed = 6;                // initial ground/obstacle speed
let speedIncreaseRate = 0.0015; // how speed ramps per frame * score
let frame = 0;
let score = 0;
let best = Number(localStorage.getItem('jw_best') || 0);
let gameOver = false;
let started = false;

// Player (runner)
const player = {
  x: 60,
  y: GROUND_Y - 46, // top
  width: 44,
  height: 46,
  vy: 0,
  grounded: true,
  sprintFrame: 0,
  draw() {
    // simple sprite: body + head + eye
    ctx.fillStyle = '#222';
    // body
    ctx.fillRect(this.x + 8, this.y + 24, 28, 18);
    // head
    ctx.fillRect(this.x, this.y, 44, 24);
    // eye (white + pupil)
    ctx.fillStyle = '#fff';
    ctx.fillRect(this.x + 30, this.y + 8, 6, 6);
    ctx.fillStyle = '#000';
    ctx.fillRect(this.x + 32, this.y + 10, 2, 2);
    // legs (animate)
    ctx.fillStyle = '#222';
    if (this.sprintFrame % 20 < 10) {
      ctx.fillRect(this.x + 10, this.y + 40, 8, 6);
      ctx.fillRect(this.x + 26, this.y + 38, 8, 8);
    } else {
      ctx.fillRect(this.x + 10, this.y + 38, 8, 8);
      ctx.fillRect(this.x + 26, this.y + 40, 8, 6);
    }
  },
  update() {
    this.vy += GRAVITY;
    this.y += this.vy;
    if (this.y >= GROUND_Y - this.height) {
      this.y = GROUND_Y - this.height;
      this.vy = 0;
      this.grounded = true;
    } else {
      this.grounded = false;
    }
    this.sprintFrame++;
  },
  jump() {
    if (this.grounded) {
      this.vy = JUMP_SPEED;
      this.grounded = false;
    }
  },
  reset() {
    this.y = GROUND_Y - this.height;
    this.vy = 0;
    this.grounded = true;
    this.sprintFrame = 0;
  }
};

// Obstacles array
let obstacles = [];

// Clouds
let clouds = [];
function spawnCloud(x) {
  clouds.push({ x: x, y: 30 + Math.random() * 50, w: 40 + Math.random() * 40, speed: 0.6 + Math.random() * 0.6 });
}

// Spawn initial clouds
for (let i = 0; i < 5; i++) spawnCloud(100 + i * 160);

// obstacle factory (cactus-like)
function spawnObstacle() {
  // variable widths/heights to mimic Dino game
  const sizes = [
    { w: 18, h: 28 },
    { w: 28, h: 38 },
    { w: 12, h: 20 },
    { w: 22, h: 30 }
  ];
  const s = sizes[Math.floor(Math.random() * sizes.length)];
  const offY = GROUND_Y - s.h;
  obstacles.push({
    x: W + 20,
    y: offY,
    w: s.w,
    h: s.h,
    passed: false
  });
}

// Utility: collision AABB
function collide(a, b) {
  return a.x < b.x + b.w &&
         a.x + a.width > b.x &&
         a.y < b.y + b.h &&
         a.y + a.height > b.y;
}

// Draw ground tile line
function drawGround() {
  ctx.fillStyle = '#777';
  ctx.fillRect(0, GROUND_Y, W, H - GROUND_Y);
  // dashed ground effect
  ctx.fillStyle = '#666';
  for (let i = 0; i < W; i += 24) {
    ctx.fillRect(i, GROUND_Y, 12, 6);
  }
}

// Score rendering (like dino)
function drawScore() {
  ctx.fillStyle = '#111';
  ctx.font = '18px monospace';
  const s = Math.floor(score);
  const sStr = s.toString().padStart(5, '0');
  ctx.fillText(sStr, W - 120, 30);
  // best
  ctx.fillStyle = '#555';
  ctx.font = '12px monospace';
  ctx.fillText('BEST ' + String(best).padStart(5,'0'), W - 220, 30);
}

function drawClouds() {
  ctx.fillStyle = '#ddd';
  clouds.forEach(c => {
    ctx.fillRect(c.x, c.y, c.w * 0.6, 12);
    ctx.fillRect(c.x + c.w*0.2, c.y - 8, c.w*0.4, 14);
  });
}

// Main loop
let nextObstacleFrame = 90 + Math.floor(Math.random()*60);

function update() {
  frame++;
  // only update when started and not gameOver
  if (started && !gameOver) {
    // speed ramps with score
    speed += speedIncreaseRate * (score/100);

    // update player
    player.update();

    // spawn obstacles
    if (frame >= nextObstacleFrame) {
      spawnObstacle();
      nextObstacleFrame = frame + 80 + Math.floor(Math.random()*90) - Math.min(60, Math.floor(score/100));
    }

    // update obstacles
    obstacles.forEach(o => {
      o.x -= speed;
      // check collision
      if (!o.passed && o.x + o.w < player.x) {
        o.passed = true;
      }
      if (collide(player, { x: o.x, y: o.y, w: o.w, h: o.h })) {
        // hit
        gameOver = true;
        started = false;
        // update best
        if (score > best) {
          best = Math.floor(score);
          localStorage.setItem('jw_best', best);
        }
      }
    });
    // remove offscreen
    obstacles = obstacles.filter(o => o.x + o.w > -50);

    // clouds move slowly
    clouds.forEach(c => c.x -= c.speed);
    if (Math.random() < 0.003) spawnCloud(W + 20);
    clouds = clouds.filter(c => c.x + c.w > -100);

    // score increments
    score += 0.2 * speed; // make score tied to speed
  }
}

function draw() {
  // clear
  ctx.clearRect(0,0,W,H);

  // sky (simple gradient)
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,'#f7f7f7');
  g.addColorStop(1,'#eef2f3');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);

  // clouds
  drawClouds();

  // ground
  drawGround();

  // obstacles
  ctx.fillStyle = '#2a2a2a';
  obstacles.forEach(o => {
    ctx.fillRect(o.x, o.y, o.w, o.h);
    // small top highlight
    ctx.fillStyle = '#444';
    ctx.fillRect(o.x, o.y, o.w, Math.max(2, Math.floor(o.h*0.18)));
    ctx.fillStyle = '#2a2a2a';
  });

  // player
  player.draw();

  // score
  drawScore();

  // messages
  if (!started && !gameOver) {
    // show big "READY SET WON" and hint similar to dino start screen
    ctx.fillStyle = '#333';
    ctx.font = '28px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('READY SET WON', W/2, H/2 - 10);
    ctx.font = '14px monospace';
    ctx.fillText('Tap / Press Space to play', W/2, H/2 + 18);
    ctx.textAlign = 'start';
  }
  if (gameOver) {
    ctx.fillStyle = '#111';
    ctx.font = '22px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('GAME OVER', W/2, H/2 - 6);
    ctx.font = '14px monospace';
    ctx.fillText('Press R or Tap to Restart', W/2, H/2 + 14);
    ctx.textAlign = 'start';
  }
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

// Input handling
function handleJumpInput() {
  if (!started) {
    started = true;
    gameOver = false;
    score = 0;
    speed = 6;
    obstacles = [];
    frame = 0;
    nextObstacleFrame = 90 + Math.floor(Math.random()*60);
    player.reset();
  }
  if (!gameOver) player.jump();
}

window.addEventListener('keydown', (e) => {
  if (e.code === 'Space' || e.code === 'ArrowUp') {
    e.preventDefault();
    handleJumpInput();
  } else if (e.key === 'r' || e.key === 'R') {
    // restart
    gameOver = false;
    started = true;
    score = 0;
    speed = 6;
    obstacles = [];
    player.reset();
  }
});

canvas.addEventListener('mousedown', (e) => {
  // on click: if gameOver -> restart; else jump / start
  if (gameOver) {
    gameOver = false;
    started = true;
    score = 0;
    speed = 6;
    obstacles = [];
    player.reset();
  } else {
    handleJumpInput();
  }
});

// touch
canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  if (gameOver) {
    gameOver = false;
    started = true;
    score = 0;
    speed = 6;
    obstacles = [];
    player.reset();
  } else {
    handleJumpInput();
  }
}, {passive:false});

// keep canvas responsive on resize while preserving internal resolution
function resizeCanvas() {
  const ratio = canvas.width / canvas.height;
  const maxW = Math.min(window.innerWidth - 40, 1000);
  const maxH = Math.min(window.innerHeight - 80, 700);
  let newW = maxW;
  let newH = Math.round(newW / ratio);
  if (newH > maxH) {
    newH = maxH;
    newW = Math.round(newH * ratio);
  }
  canvas.style.width = newW + 'px';
  canvas.style.height = newH + 'px';
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

loop(); // start render loop
</script>
</body>
</html>
